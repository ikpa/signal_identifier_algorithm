# -*- coding: utf-8 -*-
"""
Created on Mon Aug  5 13:26:56 2013

A module for calculating things about coils -- generated magnetic fields etc.

@author: Koos Zevenhoven
"""
from __future__ import unicode_literals, division

from .surfacecurrent import grid_in_space, CoilSystem, _to_hashable, printprogress  #TODO move here
import numpy as np


class DipoleSet(CoilSystem):
    """A collection of one or more dipolar coils."""

    def __init__(self, positions, area_vectors):
        """Create set of dipole coils with given positions and area vectors.

        Arguments:
            positions: dipole positions, shape (3,) or (3,n).
            area_vectors: directions and effective areas, shape (3,) or (3,n)
        """
        self._positions = np.array(positions)
        self._eff_areas = np.array(area_vectors)

        assert self._positions.shape == self._eff_areas.shape
        assert self._positions.shape[0] == 3

    def __hash__(self):
        return hash(_to_hashable((self._positions, self._eff_areas)))

    def count_modes(self):
        return self._positions.size // 3

    def generated_fields(self, points):
        """Compute the fields generated by the dipoles.

        Unit current amplitudes are assumed in the coils.

        Arguments:
            points -- a number of 3-vector points to calculate field at:
                shape = (3, n_points[, npoints2, ...])

        Returns:
            numpy array of shape (3, n_basis, n_points[, n_points2, ...])
        """
        from .vectorizetools import left_align_axes
        points = np.asarray(points)
        assert points.shape[0] == 3

        ret = np.empty((3, self.count_modes()) + points.shape[1:])

        r_p = left_align_axes(self._positions, ret)
        points = points.reshape((3, 1) + points.shape[1:])

        R = points - r_p
        m = left_align_axes(self._eff_areas, ret)

        mdotR = np.einsum("i...,i...", m, R)
        absRpow2 = np.einsum("i...,i...", R,R)
        absR = np.sqrt(absRpow2)
        ret[:] = (1e-7 * (3.0 * R * mdotR - m * absRpow2) /
                  (absR * absRpow2 * absRpow2))[:]
        return ret

    def mutual_inductances(self, other, mutuals = None):
        """Calculate mutual inductances of modes into inductance matrix.

        Calculate mutual inductances of self with other. Optionally,
        a readily allocated array or sub-array view can be given to build
        the mutual inductance matrix into.
        """

        if mutuals == None:
            mutuals = np.empty((self.count_modes(), other.count_modes()))

        fields = other.generated_fields(self._positions)
        mutuals[:] = np.tensordot(self._eff_areas, fields,
                                  axes = ([0],[0]))[:]

        return mutuals


class ScalarCoilPlate(CoilSystem):
    """A square plate with a scalar-represented coil system."""

    #TODO derive EddyPlate from this

    def __init__(self, center, h_and_v_vecs,
                 scalar_maps, gradient_maps = None, label = None):
        """Create coil system with the given scalar maps representing coils.

        Arguments:
            center -- center point of plate
            (h_vec, v_vec) -- 'horizontal' and 'vertical' side vectors
            scalar_maps -- 2D maps of the scalar coil functions
                The maps should all have the same size.
            gradient_maps -- 2D maps of the gradients of the scalar maps.
                One smaller than the scalar maps in each direction
                (corresponding to grid midpoints).
            label -- a string label for this set
        """
        if label == None:
            label = "CoilPlate"
        self.label = label

        hres = scalar_maps[0].shape[-1]
        vres = scalar_maps[0].shape[-2]

        h_vec, v_vec = h_and_v_vecs

        grid, (h_size, v_size), (h_delta, v_delta), normal = \
            grid_in_space(center, (h_vec, v_vec), (hres, vres))


        midpoints = 0.25*(grid[:,:-1,:-1] + grid[:,:-1,1:] +
                          grid[:,1:,:-1] + grid[:,1:,1:])

        (Xb,Yb) = np.meshgrid(np.linspace(0, h_size, hres),
                              np.linspace(0, v_size, vres))

        self.unit_vecs = (h_vec / h_size, v_vec / v_size)
        self.size = (h_size, v_size)
        self.deltas = (h_delta, v_delta)
        self.normal = normal
        self.center = center
        self.grid_psi = grid
        basis = [smap.reshape((1,) + smap.shape) for smap in scalar_maps]
        self.psi = np.concatenate(basis)
        if gradient_maps is None:
            self.nabla_psi = None
        else:
            basis_nabla = [gmap.reshape((1,) + gmap.shape)
                               for gmap in gradient_maps]
            self.nabla_psi = np.concatenate(basis_nabla)

        self.grid_nabla_psi = midpoints

        self.n_modes = len(self.psi)

        #make mask to fix integral terms at edges
        mask = 0.5*np.ones((self.grid_psi.shape[-2:]))
        mask[1:-1,1:-1] = np.ones((mask.shape[0]-2, mask.shape[1]-2))
        mask[0,0] = 0.25
        mask[-1,-1] = 0.25
        mask[0,-1] = 0.25
        mask[-1,0] = 0.25
        #TODO use: scipy.integrate.simps(y, x=None, dx=1, axis=-1, even='avg')[source]
        self._integral_mask = mask

    def __hash__(self):
        data = (self.label, self.unit_vecs, self.size, self.deltas,
                self.normal, self.center, self.grid_psi, self.psi,
                self.grid_nabla_psi, self.nabla_psi,
                self.n_modes)
        return hash(tuple(_to_hashable(data)))

    def count_modes(self):
        return self.n_modes

    def get_nabla_psi(self):
        """Get gradient maps, calculate and store if necessary."""
        if self.nabla_psi is None:
            self.nabla_psi = self.calculate_gradients()
        return self.nabla_psi

    def calculate_gradients(self):
        """Numerically calculate gradients of scalar functions."""
        from .vectorizetools import insert_dummy_axis
        psi = insert_dummy_axis(self.psi, 1)

        gv = psi[:,:,1:,:] - psi[:,:,:-1,:]
        gv = (gv[:,:,:,1:] + gv[:,:,:,:-1]) * (0.5 / self.deltas[1])

        gh = psi[:,:,:,1:] - psi[:,:,:,:-1]
        gh = (gh[:,:,1:,:] + gh[:,:,:-1,:]) * (0.5 / self.deltas[0])

        nabla_psi = (gh * self.unit_vecs[0].reshape((3,1,1)) + \
                     gv * self.unit_vecs[1].reshape((3,1,1)))
        return nabla_psi

    def integral(self, values):
        """Calculate integral of a function sampled on the plate.

        The grid (grid_psi or grid_nabla_psi) is selected depending on
        the size of the argument array.

        Arguments:
            values -- array of values on the grid
        """
        #TODO use: scipy.integrate.simps(y, x=None, dx=1, axis=-1, even='avg')[source]
        if values.shape[-2:] == self.grid_psi.shape[-2:]:
            mask = self._integral_mask
            if len(values.shape) == 3: #vector data, prepare for broadcast
                mask = mask.reshape((1,) + mask.shape)
        elif values.shape[-2:] == self.grid_nabla_psi.shape[-2:]:
            mask = 1.0 # no mask needed since on center points
        else:
            raise Exception("Wrong array shape to integrate over")

        dS = np.prod(self.deltas)
        return dS*(mask * np.array(values)).sum()


    def generated_fields_nogradient(self, points):
        """Compute the fields generated by the basis functions in this plate.

        Unit current amplitudes are assumed in the basis functions. The
        computation is done without knowledge about the gradient of the
        scalar function. This may be faster, but has ill-defined fields
        at the scalar function grid points.

        NOTE: It is assumed that the scalar functions go to zero at the edges
        of the plate!

        Arguments:
            points -- a number of 3-vector points to calculate field at:
                shape = (3, n_points[, npoints2, ...])

        Returns:
            numpy array of shape (3, n_basis, n_points[, n_points2, ...])
        """
        from .vectorizetools import sum_keep_axis, insert_dummy_axis

        dS = np.prod(self.deltas)
        k = 1e-7 #\mu_0/4pi (exact in SI)
        n = self.normal.reshape(1,3,1,1)

        #TODO: save memory by limiting the maximum chunk of field points
        #used at once and loop over whole buffer

        #Axes could be arranged to reduce swapping axes etc, but this
        #is probably not the bottleneck.

        point_dims = points.shape[1:]
        points = points.reshape((3, -1)).swapaxes(0,1).copy()

        dR = points.reshape((-1,3,1,1)) - self.grid_psi
        dRpow2 = sum_keep_axis(dR*dR, axis=1)
        dRm5 = dRpow2**(-5./2.)
        dRm3 = dRm5 * dRpow2
        del dRpow2

        n_fields = 3.0 * (sum_keep_axis(n*dR, axis = 1) * dRm5 * dR)
        del dRm5
        del dR
        n_fields -= n * dRm3
        del dRm3

        #fields is a vector per basis func per point (n_basis, 3, n_points)
        fields = np.einsum("...jk,...jk",
                           insert_dummy_axis(self.psi * self._integral_mask,1),
                           insert_dummy_axis(n_fields, 1))
        del n_fields

        ret = dS*k*fields.swapaxes(0,2).copy()
        #swapped axes like this: (n_points, 3, n_basis)->(3, n_basis, n_points)

        n_points = np.prod(point_dims)
        printprogress("generate_fields(): {} *for* {} points".format(self, n_points))
        return ret.reshape(ret.shape[:2] + point_dims)

    def generated_fields_gradient(self, points):
        """Compute the fields generated by the basis functions in this plate.

        Unit current amplitudes are assumed in the basis functions. The
        generated field is calculated using the gradient of the scalar
        function.

        Arguments:
            points -- a number of 3-vector points to calculate field at:
                shape = (3, n_points[, npoints2, ...])

        Returns:
            numpy array of shape (3, n_basis, n_points[, n_points2, ...])
        """
        from .vectorizetools import sum_keep_axis, insert_dummy_axis

        dS = np.prod(self.deltas)
        k = 1e-7 #\mu_0/4pi (exact in SI)
        n = self.normal

        #TODO: save memory by limiting the maximum chunk of field points
        #used at once and loop over whole buffer

        #The axes could be arranged to reduce swapping axes and reshaping,
        #but this should not be a bottleneck here

        point_dims = points.shape[1:]
        points = points.reshape((3, -1)).swapaxes(0,1).copy()

        dR = points.reshape((-1,3,1,1)) - self.grid_nabla_psi
        dR_dRm3 = dR * sum_keep_axis(dR**2, axis=1)**(-3./2.)
        dR_dRm3 = insert_dummy_axis(dR_dRm3, 1)
        del dR

        #Integrals: I1 is a vector per basis func, I2 a scalar per basis func
        I2 = np.einsum("...ijk,...ijk", dR_dRm3, self.get_nabla_psi())

        n_dot_dR_dRm3 = sum_keep_axis(n.reshape((1,1,3,1,1)) * dR_dRm3,
                                      axis=2)
        del dR_dRm3
        I1 = np.einsum("...ij,...ij", n_dot_dR_dRm3, self.get_nabla_psi())
        del n_dot_dR_dRm3

        ret = dS*k*(insert_dummy_axis(I2, None) * n - I1).swapaxes(0,2)
        #swapped axes like this: (points, basis, 3)->(3, basis, points)

        n_points = np.prod(point_dims)
        printprogress("generate_fields(): {} *for* {} points".format(self, n_points))
        ret = ret.reshape(ret.shape[:2] + point_dims).copy()
        return ret

    generated_fields = generated_fields_gradient

    def mutual_inductances(self, other, mutuals = None):
        """Calculate mutual inductances of modes into inductance matrix.

        Calculate mutual inductances of self with other. Optionally,
        a readily allocated array or sub-array view can be given to build
        the mutual inductance matrix into.
        """

        if mutuals == None:
            mutuals = np.empty((self.count_modes(), other.count_modes()))

        points = self.grid_psi
        n = self.normal

        fields = other.generated_fields(points)
        normalfield = (n.reshape((3,1,1,1)) * fields).sum(axis = 0)

        for i1 in range(self.n_modes):
            for i2 in range(other.n_modes):
                m = self.integral(self.psi[i1,:,:] * normalfield[i2,:,:])
                mutuals[i1, i2] = m
        printprogress("mutual_inductances(): {} *with* {}".format(self, other))
        return mutuals

    def plot_geometry(self, ax = None):
        """Make a 3D plot of the system geometry."""
        if ax == None:
            import matplotlib.pyplot as plt
            from mpl_toolkits.mplot3d import Axes3D
            fignum = plt.get_current_fig_manager().num
            fig = plt.figure(fignum)
            ax = Axes3D(fig)

        import random
        c = ('r','g', 'b', 'c', 'm', 'y')[random.randint(0,5)]

        ax.scatter(*self.grid_psi[:,::4,::4].reshape(3,-1), label=self.label, c=c)
        return ax